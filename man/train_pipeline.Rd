% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline.R
\name{train_pipeline}
\alias{train_pipeline}
\title{Create a train/test pipeline from individual functions}
\usage{
train_pipeline(..., response)
}
\arguments{
\item{...}{Pipe segments. Each pipe segment is a list containing at least a \code{.segment} argument, which holds the function.
Other parts of the list will be treated as additional arguments to that function. Segments can be named, but don't have to be.
The default name for segment i is \code{pipe_<i>}.
\code{\link{segment}} provides a simple wrapper for these pipe segments.

These arguments are evaluated at time of calling (so once you call the pipeline function), however if you wish to create arguments based
on the datasets just before starting the processing, remember you can always wrap a pipe with another function so you can do the calculations there.

The function should always accept at least a \code{train} argument for the train dataset.
Each function should also return a list with (at a minimum) two named items: \code{train} and \code{pipe}, a trained pipe segment.
You can create these pipe segments using \code{\link{pipe}}.

If a function also returns a \code{post_pipe} item in the list, that will be added to a post-transformation pipeline. The post-pipeline will be automatically
reversed to ensure re-transformations are executed in the correct order.}

\item{response}{Since \code{response} is a parameter often used in this package, you can set it here to have it automatically set in pipeline where needed.}
}
\value{
A function, taking as arguments \code{train}. This function will return a list of the transformed \code{train} dataset after running it through all pipeline functions,
as well as a \code{\link{pipeline}} that reproduces the process for new data. Pipelines will be named based on either the names given in the call
or default names will be generated (see param section).
}
\description{
Create a train/test pipeline from individual functions
}
\details{
Since this function returns a \code{pipe} entry in its list, it should be possible to use the result of this function in a new pipeline.
}
\examples{
library(dplyr)
set.seed(1)
train <- data_frame(a = 1:10, b = sample(c(1,2, NA), size = 10,
    replace = TRUE), c = sample(c(1,2), size = 10, replace = TRUE))
test <- data_frame(a = 1:10, b = sample(c(1,2, NA), size = 10,
    replace = TRUE), c = sample(c(1,2), size = 10, replace = TRUE))

P <- train_pipeline(
    segment(.segment = datapiper::pipe_NA_indicators),
    segment(.segment = datapiper::pipe_impute, exclude_columns = "a"),
    segment(.segment = datapiper::pipe_remove_high_correlation_features, exclude_columns = "a"),
    segment(.segment = datapiper::pipe_create_stats, stat_cols = "b",
         response = "a", functions = list("mean" = mean, "sd" = sd),
         too_few_observations_cutoff = 0)
)
trained_pipeline <- P(train = train)$pipe

train <- invoke(trained_pipeline, train)
test <- invoke(trained_pipeline, test)
}
