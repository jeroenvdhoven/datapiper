#' Generate a model to impute missing data in a column
#'
#' We don't recommend to impute categorical variables with many levels.
#'
#' @param data The dataset, as a data.frame.
#' @param column The column to be imputed. Should be a string.
#' @param NA_value A function to define what a NA is for this column which returns TRUE when a value is missing and FALSE otherwise. Will take one column vector as input.
#' @param exclude_columns Columns that shouldn't be included in the imputation.
#' @param controls Either:
#' \itemize{
#' \item NA for defaults
#' \item A list for params from xgboost. Should always contain at least \code{nrounds}.
#' }
#' @param type The type of algorithm to use for imputation. Options: mean, lm, and xgboost. Mean will calculate the mean for numeric sets and the mode for non-numerics.
#'
#' @return The model built based on \code{type}.
#' @importFrom stats lm
impute_model <- function(data, column, NA_value = is.na, exclude_columns, controls = NA, type = "xgboost"){
    if(is.function(NA_value)) {
        missing <- NA_value(select_cols(data, column))
        if(is.data.table(data)) missing <- as.logical(missing)
    }
    else stop('NA_value must be a function')
    if(sum(missing) / nrow(data) > .33) warning(paste("Warning:", sum(missing) / nrow(data) * 100L, "% of the data in column", column, "is missing\n"))

    if(is.data.table(data)) data <- data[!missing]
    else data %<>% .[!missing,]

    included_cols <- colnames(data) %>% .[
        (!. %in% c(exclude_columns, column) ) &          #All columns that are not excluded.
            (!grepl(pattern = column, x = ., fixed = T)) #All columns that contain exactly the same column name.
        ]


    if(is.na(controls)) {
        if(type == "xgboost") controls = list(nrounds = 50)
    }

    if(type == "mean"){
        target_vector <- unlist(select_cols(data, cols = column))
        if(is.numeric(target_vector)) model <- mean(target_vector)
        else model <- unique(target_vector) %>% .[which.max(tabulate(match(target_vector, .)))]
    } else if(type == "lm") {
        form <- paste0(column, " ~ `", paste0(included_cols, collapse = '` + `'), "`") %>% as.formula
        model <- lm(formula = form, data = data)
    } else if(type == "xgboost") {
        reduced_data <- colnames(data)[colnames(data) %in% c(exclude_columns, column)]
        reduced_data <- deselect_cols(data, reduced_data)
        xgbm <- xgboost::xgb.DMatrix(data = as.matrix(reduced_data), label = unlist(select_cols(data, column)))
        model <- xgboost::xgb.train(params = controls, nrounds = controls$nrounds, verbose = F, data = xgbm)
    }
    else stop("Invalid type argument for imputation")

    return(model)
}

#----------------------------------------------------------------#

#' Use the models from \code{impute_all} to impute the selected columns in data.
#'
#'
#' @param data The new dataset, as a data.frame or data.table.
#' @param columns the columns to impute.
#' @param na_function Function which returns TRUE when a value is missing and FALSE otherwise.
#' @param models The models generated by \code{impute_all_models}
#' @param included_columns what columns should used as predictors? Can be integers, logicals or column names.
#' @param verbose whether xgboost should print anything
#'
#' @return The same dataset as the imputed, but with NA values in the selected columns replaced by their estimated values.
impute_predict_all <- function(data, columns, na_function, models, included_columns, verbose = F){
    stopifnot(
        is.character(columns),
        !any(!columns %in% colnames(data)),
        is.function(na_function),
        length(models) == length(columns),
        is.character(included_columns),
        !any(!included_columns %in% colnames(data)),
        is.logical(verbose)
    )
    if(length(models) < 1) model_type <- "mean"
    else {
        m <- models[[1]]
        if(is.vector(m) && length(m) == 1) model_type <- "mean"
        else {
            if(class(m) == "xgb.Booster") model_type <- "xgboost"
            else model_type <- "lm"
        }
    }

    if(model_type %in% c("xgboost", "lm")) subset <- select_cols(data, included_columns)
    if(model_type == "xgboost") subset <- as.matrix(subset)

    for(i in seq_along(columns)){
        column <- columns[i]
        model <- models[[i]]
        if(verbose) print(column)

        target <- unlist(select_cols(data, column))
        missing_values <- na_function(target)
        if(is.data.table(data)) missing_values <- as.logical(missing_values)

        if(model_type == "mean"){
            target[missing_values] <- model
        } else {
            if(model_type == "xgboost") input_data <- subset[, colnames(subset) != column]
            else input_data <- subset
            new_values <- predict(object = model, newdata = input_data[missing_values, ])
            target[missing_values] <- new_values
        }

        if(is.data.table(data)) data[, c(column) := NULL][, c(column) := target]
        else data[, column] <- target
    }

    return(data)
}

#' Impute multiple missing columns using lm, mean, or xgboost, and perform imputation
#'
#' @param train The train dataset, as a data.frame or data.table. Data.tables may be changed by reference.
#' @param columns The columns to impute, as strings.
#' @param na_function A function which returns TRUE when a value is missing and FALSE otherwise. Will apply this function to each column. Must take one column vector as input.
#' @param exclude_columns Columns that should not be used in imputation. If lm is chosen, this will always include \code{columns}. Should be strings.
#' @param type lm, mean, or xgboost.
#' @param controls Controls for xgboost, if needed. Default to NA.
#' @param verbose Whether xgboost should print anything.
#'
#' @return A list containing the transformed train dataset and a trained pipe.
#' @export
pipe_impute <- function(train, columns,
                        na_function = is.na, exclude_columns, type = "lm",
                        controls = NA, verbose = F){
    stopifnot(
        is.data.frame(train),
        type %in% c("lm", "mean", "xgboost"),
        is.logical(verbose)
    )

    if(missing(columns)) columns <- colnames(train)[purrr::map_lgl(train, function(x) any(na_function(x), na.rm = T) && is.numeric(x))]

    if(missing(exclude_columns)) {
        if(type == "mean") exclude_columns = character(0)
        else if(type == "lm") {
            # Ensure single value columns are not used
            keep_columns <- datapiper::pipe_remove_single_value_columns(train, na_function)$pipe$args$preserved_columns
            exclude_columns <- colnames(train)[!colnames(train) %in% keep_columns]
        } else if (type == "xgboost") {
            # Ensure no non-numeric columns are used
            exclude_columns <- colnames(train)[!purrr::map_lgl(train, is.numeric)]
        }
    }

    if(type == "lm"){
        # To ensure we don't generate NA's when calling predict.lm
        exclude_columns <- c(exclude_columns, columns[!columns %in% exclude_columns])
    }

    stopifnot(
        !any(!exclude_columns %in% colnames(train))
    )

    models <- purrr::map(.x = columns, .f = function(x, train, columns, na_function, exclude_columns, controls, type){
        if(verbose) print(x)
        impute_model(data = train, column = x, NA_value = na_function, exclude_columns = exclude_columns, controls = controls, type = type)
    }, train = train, columns = columns, na_function = na_function, exclude_columns = exclude_columns, controls = controls, type = type)
    names(models) <- columns

    included_columns <- colnames(train)[!colnames(train) %in% exclude_columns]

    predict_pipe <- pipe(.function = impute_predict_all, columns = columns, na_function = na_function, models = models, included_columns = included_columns)
    train <- invoke(predict_pipe, train)
    return(list(train = train, pipe = predict_pipe))
}






